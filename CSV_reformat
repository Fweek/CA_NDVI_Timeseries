#This script takes any number of input CSV files (raw timeseries export files from Google Earth Engine) and reformats them to match the NEX Ecocast files.
# These input CSV files can have any number of columns but DATE, mean NDVI, and SIMSID must be in columns 1, 2, and 3 where column index starts at 0.
import sys,os,csv,datetime,string,numpy,re
from dateutil.parser import parse

# Get the command line arguments
usage = "usage: CSV_reformat.py <Directory path of input files> <output filename> <year>\n" + \
        "Reformats the input CSV files to match NEX files"
if len(sys.argv) < 3: #Number of arguemnts required
    print usage
    sys.exit(1)

bTime = datetime.datetime.now()

os.chdir(sys.argv[1])

#Make a new directory for the output files if it does not already exist
if not os.path.exists('Output'):
    os.makedirs('Output',)

# Loop through every file in the current working directory.
for csvFilename in os.listdir('.'):
    if not csvFilename.endswith('.csv'):
        continue # skip non-csv files

    print('Modifying ' + csvFilename + '...')

    #Open the file
    fPtr = open(csvFilename)
    if fPtr is None:
      print "Error opening %s " % csvFilename
      sys.exit(1)

    #Read in the file using csv module
    rdr= csv.reader(fPtr)
    fPtr = None

    #Create container for input
    input = []

    #Keep only columns we want: DATE in column 1, NDVI in column 2, and SIMSID in column 3
    for l in rdr:
      input.append((l[1],l[2],l[3]))

    #Remove header
    input = input[1::]

    #Find how many unique ids we have
    simsIds = [i[2] for i in input] #where i is the row in input and [2] is the SIMSID column

    #Get all the unique simsids and count them. This will be the number of rows for our new table
    yDim = len(numpy.unique(simsIds)) + 1 #adding 1 to account for row header
    print "Number of unique sims ids %d" % yDim

    # We will always have 51 columns. 5 extra + 46 timesteps
    xDim = 51

    #Create final output array
    finalOutput = numpy.ones((yDim,xDim)) * -9999.0 #fill all cells with -9999

    #Create temp output container
    tempOut = []

    #Function that checks if the input string is a DATE
    def is_date(string):
        try:
            parse(string)
            return True
        except ValueError:
            return False

    #More formatting
    for l in input:
        #Grab only date column
        dtStr = l[0]
        #Dates can be in various formats. This code can handle four different formats: yyyy-mm-dd, yyyy/mm/dd, mm-dd-yyyy, mm/dd/yyyy
        #If the input string is a date and the date format starts with yyyy do the following:
        if is_date(dtStr) == True and dtStr.startswith("20"):
            regx = re.compile('[-/]')
            #Parse out year, month, day.
            y, m, d = regx.split(str(dtStr))
            '/'.join(('20' + y.zfill(2), m.zfill(2), d.zfill(2) if len(y) == 2 else y))
            #Reformat date
            dtNum = (datetime.datetime(int(y), int(m), int(d)) - datetime.datetime(1980, 1, 1)).days
            #Replace all {nd=null} values with -9999
            ndvi = l[1]
            #If ndvi value is in {nd=0.#####} format do the following:
            if ndvi.startswith('{nd='):
                ndvi2 = string.replace(ndvi, '{nd=null}', '-9999')
                #Format NDVI to only numbers
                ndvi3 = string.replace(ndvi2, '{nd=', '')
                ndvi4 = string.replace(ndvi3, '}', '')
                tempOut.append((float(l[2]), dtNum, ndvi4))
            #Otherwise if just a value do the following:
            else:
                tempOut.append((float(l[2]), dtNum, ndvi))

        #Otherwise if the input string is a date and the date format starts with mm do the following:
        elif is_date(dtStr) == True:
            regx = re.compile('[-/]')
            #Parse out year, month, day.
            m, d, y = regx.split(str(dtStr))
            '/'.join(('20' + y.zfill(2), m.zfill(2), d.zfill(2) if len(y) == 2 else y))
            #Reformat date
            dtNum = (datetime.datetime(int(y), int(m), int(d)) - datetime.datetime(1980, 1, 1)).days
            #Replace all {nd=null} values with -9999
            ndvi = l[1]
            #If ndvi value is in {nd=0.#####} format do the following:
            if ndvi.startswith('{nd='):
                ndvi2 = string.replace(ndvi, '{nd=null}', '-9999')
                #Format NDVI to only numbers
                ndvi3 = string.replace(ndvi2, '{nd=', '')
                ndvi4 = string.replace(ndvi3, '}', '')
                tempOut.append((float(l[2]), dtNum, ndvi4))
            #Otherwise if just a value do the following:
            else:
                tempOut.append((float(l[2]), dtNum, ndvi))

    tempOut.sort()

    #Find how many unique dates we have
    allDates = [i[1] for i in tempOut]

    #Get all unique IDs and count them
    uniqueIds = numpy.unique(simsIds)
    #print uniqueIds.shape

    #Fill in the date header based on year, assuming we're looking at 2016 data
    tStart = (datetime.datetime(int(sys.argv[3]), 01, 1) - datetime.datetime(1980, 1, 1)).days
    print tStart
    tEnd = (datetime.datetime(int(sys.argv[3]), 12, 31) - datetime.datetime(1980, 1, 1)).days
    print tEnd

    indx = 5
    for i in range(tStart, tEnd, 8): #every 8th value starting at tStart
        finalOutput[0, indx] = i #take that value and put it in the finalOutput array at the specified index
        indx += 1 #index increases incrementally each loop

    finalOutput[1:yDim, 0] = uniqueIds

    for row in range(1, yDim):  # for each row in the range of SIMs IDs
        simsId = finalOutput[row, 0]  # create variable called simsId, set it equal to the simsId in the [row, 0] position
        for j in tempOut:  # then in a different list
            tempOutId = float(j[0])  # make tempOutId equal to just the SIMS ID column
            # print simsId,tempOutId
            if simsId == tempOutId:  # check to see if the two SIMS ID match up
                # Check the date and add to column
                print "IDs match", simsId, tempOutId  # if they match says so
                date = j[1]  # create variables for each column
                ndvi = j[2]
                print date, ndvi
                # which column?
                for col in range(5, 51):  # why 5?
                    dateTemp = int(finalOutput[0, col])  # make new date variable based on header
                    dateTemp2 = dateTemp+8
                    # print dateTemp,date
                    if dateTemp <= date < dateTemp2:
                        # Most dates won't match since the overpass can fall anywhere in between the 8 day period
                        #      Have to account for this to make the code work
                        # print "Dates match"
                        print row, col, ndvi
                        finalOutput[row, col] = ndvi


    #Write list to CSV
    output_destination = sys.argv[1]+'/Output/'+sys.argv[2]
    numpy.savetxt(output_destination, finalOutput, delimiter=",",fmt='%.3f')

print "Start time: ", bTime
print "End time: ", datetime.datetime.now()
